# Final-Project-A09-
A09 최종 프로젝트 : 게임 데이터 분석

# 고유키 기록용

## 넥슨 메이플스토리 API KEY : test_3b341b04580056706630a7005aa630353dc098849203dc369a4dcd875acf97c7c5c4379a7a07b52f361ffef5fab87a55

## 던파 API KEY : ZWBQ5Hcf27Dz494NprIOqSpXUZqubuLG

## 라이엇 API 키 : RGAPI-51594ed7-aa70-4a72-b8bf-314c7f733d71


# 데이터 분석 목적 설정 초안
1. API 활용하여 데이터 분석 (넥슨 - 메이플, 네오플 - 던파, 라이엇 - 롤, tft)

## 롤체 데이터로 가능한 분석 주제

# 이미 통계 사이트에서 제공하고 있는 것
1. 완성 덱 별 승률 (완성 시 평균 등수, 1등 확률, 순방 확률), pick rate (덱의 등장 확률)
2. 각 챔피언에 들어갔을 때, 가장 좋은 아이템, 덱에서 주로 어떤 챔피언에 아이템을 넣어주는지까지
3. 완성 덱 기준 챔피언 중 3성을 찍는 것이 중요한 챔피언에 별 3개 표시되어 있음 (데이터 기준 3성이 많이 찍힌 챔피언인가?)
4. 완성덱 픽률, 승률 기반으로 티어 리스트 생성
5. Augments 티어별 골랐을 때, 승률 표시
6. 아이템 별 승률, 티어 리스트
7. 귀인 시스템(이번 시즌 새로운 시스템, 게임마다 랜덤하게 귀인 챔피언이 바뀜) 어떤 귀인 챔피언 조합일때 승률이 높은가
8. 활성화시켜주었을 때, 승률이 높은 Traits(시너지)
9. 랭커 리스트 (각 랭커가 가장 잘 쓰는 챔피언)

# 통계사이트에 없으며 직접 만들어 볼수 있는 지표(인사이트)
1. 삼신기라고 불리는 템들중 중요도가 높은 템 지표 + (삼신기를 만들수 없을때 추천하는 대체 아이템)
2. 랭커 목록 옆에 그 랭커가 점수를 올릴 때, 가장 많이 사용한 덱이 나오면 좋을꺼같음(챔피언 대신에)
3. 평균적으로 순방 유저가 결정되는 라운드 평균 (현재 메타가 빠른지 느린지 파악할 수 있음 좋겠음)
4. 완벽하게 못맞춰줬을 때, 승률 차이가 많이 나는 덱 랭킹 (삼신기를 못넣었을 경우 승률 차이, 핵심 2성이나 
   3성을 못찍었을 경우 승률 차이)
5. 시너지 없이 넣어줬을 때, 가장 좋은 5코스트 챔피언 지표(단일 챔피언 밸류)


## 만들어야 하는 테이블 목록
1. 매치 데이터 팀 조합 로그
   
   식별자 : Game Id, puuid(playerId)
   컬럼 : {Game Id, puuid, 패치 버전, 참가자 티어, 경기 날짜}, 최종 등수, 총 진행한 라운드 수,
          구성 챔피언 이름, 챔피언 코스트, 챔피언 몇 성, 장착된 아이템(아이템 1,2,3), 고른 증강체(증강체1,2,3), 종료 시 레벨


## 라이엇 API 꺼내오는 방법 순서

1. 라이엇 데이터의 경우 3가지 순서를 거쳐야 함

2. 우선 유저를 특정할 수 있는 식별자인 puuid 를 추출해야함

3. puuid 를 추출하기 위해서는 우선 league/v1 API 에 저장되어있는 랭크별 닉네임 정보를 가져와야한다

4. /lol/summoner/v4/summoners/by-name/{summonerName} 이 API 를 활용해서 닉네임을 이용해 puuid 를 가져올 것이다

5. 각각의 닉네임을 넣으면서 그 유저의 puuid 를 추출해야한다 - 닉네임을 리스트로 만들고 for 문을 사용하면 쉽게 가능할 것이다

6. 원하는 구간을 설정하면 해당 구간의 결측치를 제거하고 닉네임 리스트를 추출하는 함수를 생성했다

7. /lol/summoner/v4/summoners/by-name/{summonerName} 이용하여, 닉네임 리스트를 넣으면 각 닉네임에 대응하는 puuid 리스트를
   반환하는 함수를 생성했다

8. 생성한 puuid 리스트로 game id 를 추출, 다음을 이용
   game_url = "https://Asia.api.riotgames.com/tft/" + f'match/v1/matches/by-puuid/{random_puu_id}/ids?count=20'
   
   # 여기서 'match/v1/matches/by-puuid/{random_puu_id}/ids?count=20' 앞에 f를 붙이는 이유

   ## "f"는 파이썬의 f-string입니다. f-string은 문자열 내에서 변수 값을 쉽게 사용할 수 있도록 해줍니다. f-string을 사용하면 문자열 안에 중괄호 {} 안에 변수를 넣을 수 있고, 해당 변수의 값이 그 위치에 삽입됩니다.

   ## 예를 들어, f'match/v1/matches/by-puuid/{puu_id}/ids?count=20'에서 {puu_id} 부분은 변수 puu_id의 값을 문자열 안에 삽입하는 것입니다. 이렇게 함으로써 동적인 문자열을 생성할 수 있습니다. 이전에는 문자열 포맷팅이나 문자열 연결 등을 사용하여 변수 값을 문자열에 포함시켰지만, f-string을 사용하면 더 간결하고 가독성이 좋은 코드를 작성할 수 있습니다.

9. 추출한 게임 아이디 중 하나를 이용, 그 게임의 참가한 유저 중 한명의 게임이 끝난시점에 덱구성, 아이템 정보 등 조회


## 프로젝트 진행 상황 정리

1. (<1. make TFT ranker puuid table.ipynb>) 파일을 이용하면 모든 랭커 구간의 유저 정보, 및 puuid 를 조회하여 
   csv 파일로 만들수 있도록 쿼리 작성 완료

   # 과정 1의 최종 결과물 : (ranker_name_puuid.csv)

2. (<2. make tier_gameId table.ipynb>) 파일을 이용하면 앞서서 만든 csv 파일을 이용하여 모든 랭커 구간의
   gameId 와 해당 게임의 티어까지 조회하여 csv 파일로 만들 수 있도록 쿼리 작성 완료

   # 과정 2의 최종 결과물 : (tier_and_gameId.csv)

3. (<3. make match info table.ipynb>) 파일을 이용하면 앞서서 만든 (tier_and_gameId.csv) 테이블에 존재하는 모든 gameId 에
   대한 game results data 를 조회하고, 

   각 participants 의 최종 게임 결과를 각각의 행으로 분리하여 csv 로 저장할수 있도록 쿼리 작성했음

   # 과정 3의 최종 결과물 : (game_results_of_each_participants.csv)

4. (<4. make units combination table.ipynb>) 을 이용하면 각각의 참가자가 게임 종료 시점에 들고있었던 기물의 종류와 각 기물들이
   몇성이 찍혀있는지 확인할 수 있는 테이블이 만들수 있도록 쿼리를 작성하였다

   # 과정 4의 결과물 : (units_tiers_and_combination.csv)


5. (<5. make units item table.ipynb>) 를 이용하면, 각각의 유닛이 게임 종료시에 가지고있던 아이템의 정보가 리스트 형태로
   저장되어있는 테이블을 만들수 있도록 쿼리를 작성하였다

   # 과정 5의 결과물 : (units_item_list.csv)


6. 앞에서 만든 유닛이 장착하고 있는 아이템 테이블은 itemNames 컬럼이 문자열 형태로 되어있었다
   이를 list 형태로 변환해주면서 번역의 편의성을 위해서 list 안의 값들을 explode 하고 item1, item2, item3 컬럼에 배분하였다

   EDA 진행중 챔피언이 같은 아이템 3개를 들고있더라도 순서의 차이때문에, 제대로 통계값이 도출되지않는 문제에 직면했고,
   이를 해결해주기 위해서 list 안의 값들을 정렬해주는 전처리를 우선적으로 진행해주었다

   이후, 보편적인 삼신기 아이템을 가지고있는 챔피언 '바드'의 데이터로 통계값을 구하는 테스트를 진행해보았다

   # 6의 내용들은 (<explode item table.ipynb>) 안에서 확인할 수 있다
   # 6의 결과물 : (<champion and item table(for translation).csv>)


7. 팀원분이 만든 테이블을 모두 번역 처리해주셨음

8. 번역된 테이블을 가지고 덱 조합을 나누기 위하여 클러스터링을 진행

9. Units table 과 Traits 테이블을 가지고 모두 클러스터링을 진행해봄 - 생각보다 만족스러운 결과를 얻을수 없었음

10. K 값을 너무 낮게 잡은 것일수도 있으므로 조금더 높게 잡아볼 필요(오히려 랭커의 데이터이므로 좀더 유동성이 클수도 있겠다는 생각)

   

