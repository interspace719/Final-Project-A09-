# Final-Project-A09-
A09 최종 프로젝트 : 게임 데이터 분석

# 고유키 기록용

## 넥슨 메이플스토리 API KEY : test_3b341b04580056706630a7005aa630353dc098849203dc369a4dcd875acf97c7c5c4379a7a07b52f361ffef5fab87a55

## 던파 API KEY : ZWBQ5Hcf27Dz494NprIOqSpXUZqubuLG

## 라이엇 API 키 : RGAPI-51594ed7-aa70-4a72-b8bf-314c7f733d71


# 데이터 분석 목적 설정 초안
1. API 활용하여 데이터 분석 (넥슨 - 메이플, 네오플 - 던파, 라이엇 - 롤, tft)

## 롤체 데이터로 가능한 분석 주제

# 이미 통계 사이트에서 제공하고 있는 것
1. 완성 덱 별 승률 (완성 시 평균 등수, 1등 확률, 순방 확률), pick rate (덱의 등장 확률)
2. 각 챔피언에 들어갔을 때, 가장 좋은 아이템, 덱에서 주로 어떤 챔피언에 아이템을 넣어주는지까지
3. 완성 덱 기준 챔피언 중 3성을 찍는 것이 중요한 챔피언에 별 3개 표시되어 있음 (데이터 기준 3성이 많이 찍힌 챔피언인가?)
4. 완성덱 픽률, 승률 기반으로 티어 리스트 생성
5. Augments 티어별 골랐을 때, 승률 표시
6. 아이템 별 승률, 티어 리스트
7. 귀인 시스템(이번 시즌 새로운 시스템, 게임마다 랜덤하게 귀인 챔피언이 바뀜) 어떤 귀인 챔피언 조합일때 승률이 높은가
8. 활성화시켜주었을 때, 승률이 높은 Traits(시너지)
9. 랭커 리스트 (각 랭커가 가장 잘 쓰는 챔피언)

# 통계사이트에 없으며 직접 만들어 볼수 있는 지표(인사이트)
1. 삼신기라고 불리는 템들중 중요도가 높은 템 지표 + (삼신기를 만들수 없을때 추천하는 대체 아이템)
2. 랭커 목록 옆에 그 랭커가 점수를 올릴 때, 가장 많이 사용한 덱이 나오면 좋을꺼같음(챔피언 대신에)
3. 평균적으로 순방 유저가 결정되는 라운드 평균 (현재 메타가 빠른지 느린지 파악할 수 있음 좋겠음)
4. 완벽하게 못맞춰줬을 때, 승률 차이가 많이 나는 덱 랭킹 (삼신기를 못넣었을 경우 승률 차이, 핵심 2성이나 
   3성을 못찍었을 경우 승률 차이)
5. 시너지 없이 넣어줬을 때, 가장 좋은 5코스트 챔피언 지표(단일 챔피언 밸류)


## 만들어야 하는 테이블 목록
1. 매치 데이터 팀 조합 로그
   
   식별자 : Game Id, puuid(playerId)
   컬럼 : {Game Id, puuid, 패치 버전, 참가자 티어, 경기 날짜}, 최종 등수, 총 진행한 라운드 수,
          구성 챔피언 이름, 챔피언 코스트, 챔피언 몇 성, 장착된 아이템(아이템 1,2,3), 고른 증강체(증강체1,2,3), 종료 시 레벨


## 라이엇 API 꺼내오는 방법 순서

1. 라이엇 데이터의 경우 3가지 순서를 거쳐야 함

2. 우선 유저를 특정할 수 있는 식별자인 puuid 를 추출해야함

3. puuid 를 추출하기 위해서는 우선 league/v1 API 에 저장되어있는 랭크별 닉네임 정보를 가져와야한다

4. /lol/summoner/v4/summoners/by-name/{summonerName} 이 API 를 활용해서 닉네임을 이용해 puuid 를 가져올 것이다

5. 각각의 닉네임을 넣으면서 그 유저의 puuid 를 추출해야한다 - 닉네임을 리스트로 만들고 for 문을 사용하면 쉽게 가능할 것이다

6. 원하는 구간을 설정하면 해당 구간의 결측치를 제거하고 닉네임 리스트를 추출하는 함수를 생성했다

7. /lol/summoner/v4/summoners/by-name/{summonerName} 이용하여, 닉네임 리스트를 넣으면 각 닉네임에 대응하는 puuid 리스트를
   반환하는 함수를 생성했다

8. 생성한 puuid 리스트로 game id 를 추출, 다음을 이용
   game_url = "https://Asia.api.riotgames.com/tft/" + f'match/v1/matches/by-puuid/{random_puu_id}/ids?count=20'
   
   # 여기서 'match/v1/matches/by-puuid/{random_puu_id}/ids?count=20' 앞에 f를 붙이는 이유

   ## "f"는 파이썬의 f-string입니다. f-string은 문자열 내에서 변수 값을 쉽게 사용할 수 있도록 해줍니다. f-string을 사용하면 문자열 안에 중괄호 {} 안에 변수를 넣을 수 있고, 해당 변수의 값이 그 위치에 삽입됩니다.

   ## 예를 들어, f'match/v1/matches/by-puuid/{puu_id}/ids?count=20'에서 {puu_id} 부분은 변수 puu_id의 값을 문자열 안에 삽입하는 것입니다. 이렇게 함으로써 동적인 문자열을 생성할 수 있습니다. 이전에는 문자열 포맷팅이나 문자열 연결 등을 사용하여 변수 값을 문자열에 포함시켰지만, f-string을 사용하면 더 간결하고 가독성이 좋은 코드를 작성할 수 있습니다.

9. 추출한 게임 아이디 중 하나를 이용, 그 게임의 참가한 유저 중 한명의 게임이 끝난시점에 덱구성, 아이템 정보 등 조회


## 프로젝트 진행 상황 정리

1. (<1. make TFT ranker puuid table.ipynb>) 파일을 이용하면 모든 랭커 구간의 유저 정보, 및 puuid 를 조회하여 
   csv 파일로 만들수 있도록 쿼리 작성 완료

   # 과정 1의 최종 결과물 : (ranker_name_puuid.csv)

2. (<2. make tier_gameId table.ipynb>) 파일을 이용하면 앞서서 만든 csv 파일을 이용하여 모든 랭커 구간의
   gameId 와 해당 게임의 티어까지 조회하여 csv 파일로 만들 수 있도록 쿼리 작성 완료

   # 과정 2의 최종 결과물 : (tier_and_gameId.csv)

3. (<3. make match info table.ipynb>) 파일을 이용하면 앞서서 만든 (tier_and_gameId.csv) 테이블에 존재하는 모든 gameId 에
   대한 game results data 를 조회하고, 

   각 participants 의 최종 게임 결과를 각각의 행으로 분리하여 csv 로 저장할수 있도록 쿼리 작성했음

   # 과정 3의 최종 결과물 : (game_results_of_each_participants.csv)

   

